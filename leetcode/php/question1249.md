```
给你一个由 '('、')' 和小写字母组成的字符串 s。

你需要从字符串中删除最少数目的 '(' 或者 ')' （可以删除任意位置的括号)，使得剩下的「括号字符串」有效。

请返回任意一个合法字符串。

有效「括号字符串」应当符合以下 任意一条 要求：

空字符串或只包含小写字母的字符串
可以被写作 AB（A 连接 B）的字符串，其中 A 和 B 都是有效「括号字符串」
可以被写作 (A) 的字符串，其中 A 是一个有效的「括号字符串」
 

示例 1：
输入：s = "lee(t(c)o)de)"
输出："lee(t(c)o)de"
解释："lee(t(co)de)" , "lee(t(c)ode)" 也是一个可行答案。

示例 2：
输入：s = "a)b(c)d"
输出："ab(c)d"

示例 3：
输入：s = "))(("
输出：""
解释：空字符串也是有效的
 
提示：
1 <= s.length <= 105
s[i] 可能是 '('、')' 或英文小写字母
```

```
两个栈实现，思路：

创建左右两个栈，用于保存下标值
遍历字符串，遇到左括号在左栈中保存自个的下标值（等会看看有没有人配对，没人配对就根据这个下标值来删除括号）
遇到右括号首先检测左栈是否有值，两种情况：
3.1 若左栈为空，说明这个右括号是单身的，记录下标值，等会删除他
3.2 若左栈不为空，说明右括号是有对象的，将他对象从左栈中删除，放过他们
循环跑完剩下的左栈和右栈都是单身的，删除即可.
```

```
class Solution {

    /**
     * @param String $s
     * @return String
     */
    function minRemoveToMakeValid($s) {
        $left = [];
        $right = [];
        for ($i = 0; $i < strlen($s); $i++) {
            if ($s[$i] == '(') {
                $left[] = $i;
            } elseif ($s[$i] == ')') {
                if (empty($left)) {
                    $right[] = $i;
                } else {
                    array_pop($left);
                }
            }
        }
        $res = '';
        for ($j = 0; $j < strlen($s); $j++) {
            if (in_array($j, $left) || in_array($j, $right)) {
                continue;
            }
            $res .= $s[$j];
        }
        return $res;
    }
}
```