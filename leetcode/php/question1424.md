```
给你一个列表 nums ，里面每一个元素都是一个整数列表。请你依照下面各图的规则，按顺序返回 nums 中对角线上的整数。

 

示例 1：



输入：nums = [[1,2,3],[4,5,6],[7,8,9]]
输出：[1,4,2,7,5,3,8,6,9]
示例 2：



输入：nums = [[1,2,3,4,5],[6,7],[8],[9,10,11],[12,13,14,15,16]]
输出：[1,6,2,8,7,3,9,4,12,10,5,13,11,14,15,16]
示例 3：

输入：nums = [[1,2,3],[4],[5,6,7],[8],[9,10,11]]
输出：[1,4,2,5,3,8,6,9,7,10,11]
示例 4：

输入：nums = [[1,2,3,4,5,6]]
输出：[1,2,3,4,5,6]
 

提示：

1 <= nums.length <= 10^5
1 <= nums[i].length <= 10^5
1 <= nums[i][j] <= 10^9
nums 中最多有 10^5 个数字。
```

```
[
  [1,2,3,4,5],
  [6,7],
  [8],
  [9,10,11],
  [12,13,14,15,16]
]

单看坐标
[
  [(0,0),(0,1),(0,2),(0,3),(0,4)]
  [(1,0),(1,1)]
  [(2,0)]
  [(3,0),(3,1),(3,2)]
  [(4,0),(4,1),(4,2),(4,3),(4,4)]
]

转化为
[
  [0,1,2,3,4]
  [1,2]
  [2]
  [3,4,5]
  [4,5,6,7,8]
]

直接按标号分组
[[0][1,1][2,2,2][3,3][4,4,4][5,5][6][7][8]]
然后合起来就是了（合的过程要注意加入的顺序）
```

```
class Solution {

    /**
     * @param Integer[][] $nums
     * @return Integer[]
     */
    function findDiagonalOrder($nums) {
        $res = [];
        for ($i = 0; $i < count($nums); $i++) {
            for ($j = 0; $j < count($nums[$i]); $j++) {
                $sum_num = $i + $j;
                $res[$sum_num][] = $nums[$i][$j];
            }
        }
        $ret = [];
        for ($p = 0; $p < count($res); $p++) {
            for ($q = count($res[$p]) - 1; $q >= 0; $q--) {
                $ret[] = $res[$p][$q];
            }
        }
        return $ret;
    }
}
```